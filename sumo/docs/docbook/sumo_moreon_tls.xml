<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<book>
  <bookinfo>
    <title id="more_tls">SUMO - More on... Traffic Lights</title>

    <author>
      <firstname>Daniel</firstname>

      <surname>Krajzewicz</surname>

      <affiliation>
        <address><email>Daniel.Krajzewicz@dlr.de</email></address>
      </affiliation>
    </author>

    <author>
      <firstname>Danilot</firstname>

      <surname>Tete Boyom</surname>
    </author>

    <releaseinfo>$Revision$</releaseinfo>
  </bookinfo>

  <toc></toc>

  <chapter id="more_tls-intro">
    <title>Introduction</title>

    <sect1 id="more_tls-intro-information">
      <title>Document Information</title>

      <para>This document is a part of <emphasis>SUMO</emphasis> -
      <emphasis>S</emphasis>imulation of <emphasis>U</emphasis>rban
      <emphasis>MO</emphasis>bility. SUMO is an open source microscopic road
      traffic simulation. It can be found under <ulink
      url="http://sumo.sourceforge.net/">http://sumo.sourceforge.net/</ulink>.</para>

      <para>This document fits to version 0.9.5. We will try to keep it up to
      date with the next versions.</para>
    </sect1>

    <sect1 id="more_tls-intro-scope">
      <title>Document Scope</title>

      <para>Herein, we will describe how traffic lights are implemented and
      used within SUMO. This document has the following structure:</para>

      <orderedlist>
        <listitem>
          <para>As basically traffic lights affect the right-of-way rules at a
          junction, we will first describe how right-of-way rules are
          implemented within SUMO and how traffic lights are implemented as an
          extension to this concept.</para>
        </listitem>

        <listitem>
          <para>Algorithms already implemented in SUMO are described and it is
          shown how they work.</para>
        </listitem>

        <listitem>
          <para>An introduction about how to implement own traffic light
          algorithms is given.</para>
        </listitem>

        <listitem>
          <para>It is described, how traffic light logics and row-logics are
          loaded and instantiiated.</para>
        </listitem>
      </orderedlist>
    </sect1>

    <sect1 id="more_tls-intro-audience">
      <title>Document Audience</title>

      <para>This document contains information for <emphasis>users</emphasis>
      who are interested how traffic light systems are implemented in SUMO and
      who need further information on how to define own tls programs. It is
      also meant for <emphasis>developers</emphasis> who want to extend
      SUMO.</para>
    </sect1>

    <sect1 id="more_tls-intro-structure">
      <title>Document Structure</title>

      <para>At first, a description about how right-of-way rules are applied
      and how traffic lights work in SUMO is given.</para>

      <para>Then, tls-algorithms already implemented in SUMO are described
      <remark>(TBD: incomplete)</remark>.</para>

      <para>Then, it is shown how one can implement own tls algorithms
      <remark>(TBD: incomplete)</remark>.</para>

      <para>Then it is described how right-of-way rules and tls-algorithms are
      loaded.</para>

      <para>We close with some further information about how to deal with tls
      within SUMO. These information are mainly answers to questions posted by
      users.</para>
    </sect1>
  </chapter>

  <chapter id="more_tls-right_of_way">
    <title>Right-Of-Way Rules in SUMO</title>

    <sect1 id="more_tls-right_of_way-links">
      <title>Links: A Connection between Lanes</title>

      <para>Each lane (<classname>MSLane</classname>) beside dead ends has a
      list of at least one following lane. A link (MSLink) connects this
      following and the lane we regard. Basically, we consider two types of
      connections between lanes. In the first case, vehicles are able to pass
      the connection every time, without regarding other, possibly crossing
      traffic. Such connections may be found at highways or if the connection
      is a primary road and it is assured that the vehicle is able to pass
      this link without a collision. Such connections are called
      "<emphasis>priorised</emphasis>" connections. The other connections are
      called "<emphasis>unpriorised</emphasis>". They are found on minor roads
      and a vehicle passing them must decelerate in front of them, because it
      may have to stop to let other vehicles pass the junction first. Please
      regard, that a junction may consist of several connections (links) of
      different type.</para>
    </sect1>

    <sect1 id="more_tls-right_of_way-links_usage">
      <title>Usage of Links within the Simulation</title>

      <para>If a vehicle approaches a link (<classname>MSLink</classname>), it
      lets the link know about it by calling <function>void
      <classname>MSLink</classname>::setApproaching(<classname>MSVehicle</classname>
      *approaching)</function>. This is done in <function>void
      <classname>MSVehicle</classname>::vsafeCriticalCont( SUMOReal boundVSafe
      )</function> as soon as a vehicle will have to decelerate to manage to
      stop in front of the link. Even if the vehicle is too near or too fast
      to decelerate in front of the link, the link will still be informed
      until the vehicle will finally pass it. By doing this, each link knows
      whether a vehicle is approaching or not and stores this vehicle in
      <varname>MSLink::myApproaching</varname>. In addition, the information
      about approaching a link is stored by the link into the
      <classname>MSLogicJunction::Request </classname>structure of the
      junction (<classname>MSRightOfWayJunction</classname>) it belongs to.
      After all vehicles have stored this information,
      <classname>MSRightOfWayJunction</classname> is able to compute which of
      the approaching vehicles will have to wait and which not using its
      <classname>MSJunctionLogic</classname>.</para>

      <para>If you are confused about all these classes, the next diagram
      which shows how the hierarchy of SUMO junction classes, may help
      you.</para>

      <note>
        <para>Remark that some of the classes are interfaces with only one
        implementation. It is possible, that this tree is a matter to change
        in the next time.</para>
      </note>

      <figure id="img_junction_classes">
        <title>Junction classes within SUMO</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="./gfx/more/CD_Junctions_small.png"
                       format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>

      <para>In the next pass (but within the same simulation step), each of
      the vehicles is touched again, but by now it is known whether the
      vehicle is allowed to pass the junction using his link or not. If not,
      the vehicle will decelerate and stop in front of the link (or a vehicle
      in front of it, that is also waiting). If the link is "unpriorised", the
      vehicle will decelerate in front of it, even if it may pass it. If the
      link is "priorised" and the vehicle may pass, the vehicle will continue
      his drive without being hindered.</para>
    </sect1>

    <sect1 id="more_tls-right_of_way-logic_junctions">
      <title>Setting Information by MSLogicJunctions</title>

      <para>As we have seen, a MSLogicJunction gives way to the vehicles after
      the knowledge about all incoming vehicles has been set. We have seen
      that this information was stored in a structure named
      "<classname>MSLogicJunction::Reques</classname>t". This is simply a list
      of bits, a <classname>std::bitset&lt;64&gt;</classname>, where each bit
      represents the information whether a certain link is approached by a
      vehicle currently (it's then set to true otherwise it's false).</para>

      <para>What traffic lights do is simply to mask off those requests which
      are approaching a currently red sign. By doing this, the response for
      these streams is also set to false which forces the approaching vehicles
      to stop in front of the junction. Furthermore, this method keeps the
      row-logic of the junction untouched, what allows to use it for letting
      vehicles moving left - in the part of the world that drives on the right
      sied, that means those streams which have to cross an enemy stream -
      wait until there is a gap in the enemy stream they can use to move over
      the junction.</para>

      <figure id="img_tls_classes">
        <title>TLS classes within SUMO</title>

        <mediaobject>
          <imageobject>
            <imagedata align="center"
                       fileref="./gfx/more/CD_TrafficLights_small.png"
                       format="PNG" />
          </imageobject>
        </mediaobject>
      </figure>
    </sect1>

    <sect1 id="more_tls-right_of_way-switching_phases">
      <title>Switching the Phases</title>

      <para>What we furthermore need to know is how a traffic light is forces
      to switch its phases and how the links get informed about this. When
      being instantiated, the tls adds an event to SUMO's event handler
      (<classname>MSEventHandler</classname>). This is done within the
      <classname>MSTrafficLightLogic</classname>-constructor, a class from
      which all tls algorithms are derived (see above). This event, being a
      <classname>MSTrafficLightLogic::SwitchCommand</classname> executes the
      following steps:</para>

      <programlisting>SUMOTime execute() {
   // get the current phase index
   size_t step1 = myTLLogic-&gt;getStepNo();
   // try to switch, get next duration
   SUMOTime next = myTLLogic-&gt;trySwitch();
   // get the phase index after possible switch
   size_t step2 = myTLLogic-&gt;getStepNo();
   // has the phase changed?
   if(step1!=step2) {
      // yes -&gt; do some further actions (see below)
      myTLLogic-&gt;onSwitch();
      // inform the links about current state
      myTLLogic-&gt;setLinkPriorities();
   }
   // return period after which the tls shall be tried to switch again
   return next;
}
</programlisting>

      <para>Let's review it. At first, we remember the state of the tls before
      trying to switch it in the variable <varname>step1</varname>. This
      "state" is simply the index of the current tls phase. Then, we try to
      switch the tls using <function>trySwitch()</function> and gain the
      period to the next try which we save in <varname>next</varname>. After
      this, we check whether the tls has really changed by asking for its
      current step. If the step before and the step after trying to switch the
      tls are not the same, the tls has switched. We then inform the links
      about it using the
      <classname>MSTrafficLightLogic::setLinkPriorities</classname> function.
      The call to <function>onSwitch</function> should not bother you, herein.
      It is not a part of the tls-steering, but used to inform connected
      structures about the phase change. By now, only assigned detectors may
      be informed and their assignment is done separately from the
      tls-implementations. The comparison between the step before and after
      trying to switch is needed, as maybe the tls decides not to switch, yet,
      although the phases duration is over <remark>(TBD: add a description of
      agentbased tls)</remark>. After all has been done, we return the period
      to wait until we again try to switch the tls. If you want, your
      implementation of "<function>trySwitch</function>" may always return 1
      in order to check the tls each simulation step.</para>
    </sect1>

    <sect1 id="more_tls-right_of_way-whole">
      <title>The whole procedure</title>

      <para>So the whole procedure of bringing a vehicle save over a junctions
      is as following:</para>

      <procedure>
        <step>
          <para><function>MSNet::myJunctions-&gt;resetRequests();</function></para>

          <para>This resets all junctions' requests to false, that means, that
          no vehicles from previous steps may inference with the current
          network state</para>
        </step>

        <step>
          <para>... (several other things may happen, here)</para>
        </step>

        <step>
          <para><function>MSNet::myEdges-&gt;moveCritical();</function></para>

          <para>Herein, vehicles which approach a junction set their
          request</para>
        </step>

        <step>
          <para><function>MSNet::myLogics-&gt;maskRedLinks();</function></para>

          <para>Requests for vehicles which have red are reset to false</para>
        </step>

        <step>
          <para><function>MSNet::myJunctions-&gt;setAllowed();</function></para>

          <para>The junctions compute which vehicles may pass them and which
          have to wait</para>
        </step>

        <step>
          <para><function>MSNet::myLogics-&gt;maskYellowLinks();</function></para>

          <para>Reallow vehicles trying to pass a yellow tls to pass the
          junction</para>
        </step>

        <step>
          <para><function>MSNet::myEdges-&gt;moveFirst();</function></para>

          <para>Move all those vehicles (not only the first one, but all first
          ones) that approach a junction</para>
        </step>
      </procedure>

      <para>What is the meaning of the sixth step? Imagine what shall happen
      with vehicles driving over yellow. They should stop, but if they are too
      near to the junction, one has to let them through. Also, they have to be
      taken into account if an enemy stream exists. In this case, they maybe
      have to make vehicles on this stream wait. To achieve this, at first
      only red links are set to false. This is given as input to the
      junction's row-logics and that lets all vehicles having red wait,
      vehicles which have yellow may be able to pass the junction. Then,
      vehicles having yellow are set to false which lets them try to stop in
      front of the tls.</para>
    </sect1>
  </chapter>

  <chapter id="more_tls-existing_algorithms">
    <title>Existing TLS-Algorithms in SUMO</title>

    <sect1 id="more_tls-existing_algorithms-static">
      <title>Static TLS (MSSimpleTrafficLightLogic)</title>

      <para>This tls-type simply obtains the list of phases from the
      description and switches between the cycles after each cycle's period is
      over. We have seen that the tls algorithm is stored in
      <function>trySwitch()</function>. What a simple traffic light's
      implementation does is the following:</para>

      <programlisting>SUMOTime
MSSimpleTrafficLightLogic::trySwitch()
{
    // increment the index
    myStep++;
    // if the last phase was reached ...
    if(myStep==myPhases.size()) {
        // ... set the index to the first phase
        myStep = 0;
    }
    // return offset to the next switch
    assert(myPhases.size()&gt;myStep);
    return myPhases[myStep]-&gt;duration;
}
</programlisting>

      <para>That means that we simply rotate our index over the phases and
      return each phase's duration as the time that has to pass before the
      traffic light is switched one step further.</para>
    </sect1>
  </chapter>

  <chapter id="more_tls-implement_own">
    <title>Implementing Own TLS-Algorithms</title>

    <sect1 id="more_tls-implement_own-apis">
      <title>Existing APIs</title>

      <para>This tls-type simply obtains the list of phases from the
      description and switches between the cycles after each cycle's period is
      over. We have seen that the tls algorithm is stored in
      <function>trySwitch()</function>. What a simple traffic light's
      implementation does is the following:</para>

      <programlisting>SUMOTime
MSSimpleTrafficLightLogic::trySwitch()
{
    // increment the index
    myStep++;
    // if the last phase was reached ...
    if(myStep==myPhases.size()) {
        // ... set the index to the first phase
        myStep = 0;
    }
    // return offset to the next switch
    assert(myPhases.size()&gt;myStep);
    return myPhases[myStep]-&gt;duration;
}
</programlisting>

      <para>That means that we simply rotate our index over the phases and
      return each phase's duration as the time that has to pass before the
      traffic light is switched one step further.</para>
    </sect1>
  </chapter>

  <chapter id="more_tls-loading">
    <title>Loading of TLS- and ROW-logics</title>

    <para>Within the next subchapters, we will describe what all these
    information means and how it is parsed.</para>

    <sect1 id="more_tls-loading-representation">
      <title>XML-Representation</title>

      <sect2 id="more_tls-loading-representation-tls_logics">
        <title>Description of TLS-Logics</title>

        <para>Normally, the descriptions of traffic lights are stored within
        the network descriptions and look like this (example from
        <filename>cross3ltl.net.xml</filename>):</para>

        <para><programlisting format="linespecific"
        linenumbering="unnumbered"><sgmltag>&lt;tl-logic type="static"&gt;</sgmltag>
   <sgmltag>&lt;key&gt;</sgmltag>0<sgmltag>&lt;/key&gt;</sgmltag>
   <sgmltag>&lt;subkey&gt;</sgmltag>0<sgmltag>&lt;/subkey&gt;</sgmltag>
   <sgmltag>&lt;phaseno&gt;</sgmltag>8<sgmltag>&lt;/phaseno&gt;</sgmltag>
   <sgmltag>&lt;offset&gt;</sgmltag>0<sgmltag>&lt;/offset&gt;</sgmltag>
   <sgmltag>&lt;phase duration="20" phase="0000111100001111" brake="1111110011111100" \
      yellow="0000000000000000"/&gt;</sgmltag>
   <sgmltag>&lt;phase duration="4" phase="0000110000001100" brake="1111111111111111" \
      yellow="0000001100000011"/&gt;</sgmltag>
   <sgmltag>&lt;phase duration="3" phase="0000110000001100" brake="1111001111110011" \
      yellow="0000000000000000"/&gt;</sgmltag>
   <sgmltag>&lt;phase duration="4" phase="0000000000000000" brake="1111111111111111" \
      yellow="0000110000001100"/&gt;</sgmltag>
   <sgmltag>&lt;phase duration="20" phase="1111000011110000" brake="1100111111001111" \
      yellow="0000000000000000"/&gt;</sgmltag>
   <sgmltag>&lt;phase duration="4" phase="1100000011000000" brake="1111111111111111" \
      yellow="0011000000110000"/&gt;</sgmltag>
   <sgmltag>&lt;phase duration="3" phase="1100000011000000" brake="0011111100111111" \
      yellow="0000000000000000"/&gt;</sgmltag>
   <sgmltag>&lt;phase duration="4" phase="0000000000000000" brake="1111111111111111" \
      yellow="1100000011000000"/&gt;</sgmltag>
<sgmltag>&lt;/tl-logic&gt;</sgmltag></programlisting></para>

        <para>This description is build during network conversion/generation
        within the netbuilding classes.</para>

        <para>The meaning of the tags and the information stored within them
        is the following:</para>

        <itemizedlist>
          <listitem>
            <para><sgmltag>tl-logic</sgmltag>: defines the begin of the
            description of a tls-logic</para>

            <para>Attributes:
            <sgmltag>type="static|actuated|agentbased"</sgmltag>; describes
            which tls-algorithm shall be used by this tls (string-enum)</para>

            <para>Information in CDATA: none</para>
          </listitem>

          <listitem>
            <para><sgmltag>key</sgmltag>: defines the begin of the description
            of a tls-logic</para>

            <para>Attributes: none</para>

            <para>Information in CDATA: the key (name) of the tls
            (string)</para>
          </listitem>

          <listitem>
            <para><sgmltag>subkey</sgmltag>: the subkey of the logic;
            different programs for the same junction must be distinct; used
            since version 0.9.4</para>

            <para>Attributes: none</para>

            <para>Information in CDATA: a name (subid) of the logic</para>
          </listitem>

          <listitem>
            <para><sgmltag>phaseno</sgmltag>: the number of phases this
            tls-logic has</para>

            <para>Attributes: none</para>

            <para>Information in CDATA: the number of phases of the logic
            (int)</para>
          </listitem>

          <listitem>
            <para><sgmltag>offset</sgmltag>: the offset by which the tls shall
            change to next phase</para>

            <para>This allows you to "rotate" the red/green phases. The offset
            is a delay to the simulation begin given in seconds with which the
            tls shall change to the next phase for the first time.</para>

            <para>Attributes: none</para>

            <para>Information in CDATA: the offset in seconds (int)</para>
          </listitem>

          <listitem>
            <para><sgmltag>phase</sgmltag>: definition of a phase (see
            below)</para>
          </listitem>
        </itemizedlist>

        <para>Please remark, that since version 0.9.4 there is no
        <sgmltag>inclanes</sgmltag>-tag within a program's description and
        that "<sgmltag>logicno</sgmltag>" has been renamed to
        "<sgmltag>subkey</sgmltag>".</para>

        <para>The definitions of a phase should be investigated more deeply.
        Each phase has an own definition and the number of such definitions
        should be equal to the value stored in <sgmltag>phaseno</sgmltag>. The
        mandatory attributes store the following information:</para>

        <itemizedlist>
          <listitem>
            <para><sgmltag>duration</sgmltag>: the duration of the phase in
            seconds</para>
          </listitem>

          <listitem>
            <para><sgmltag>phase</sgmltag>: a bitset which holds the
            information which streams have a "green" light (1). Vehicles
            within these streams are allowed to pass the junctions, vehicles
            within streams that have a zero (0) here, have either "red" light
            in front or a "yellow" one</para>
          </listitem>

          <listitem>
            <para><sgmltag>brake</sgmltag>: a bitset which holds the
            information which streams have to decelerate in front of the
            junction. Vehicles within a stream may have to decelerate either
            because they have a red or yellow light or because a foe stream
            has green, to (this is mostly the case for left-turning streams).
            Streams that have to decelerate are marked with a 1, here, zero
            (0) means the vehicles may pass without decelerating in front of
            the tls</para>
          </listitem>

          <listitem>
            <para><sgmltag>yellow</sgmltag>: a bitset which holds the
            information which vehicles are in front of yellow lights
            (1).</para>
          </listitem>
        </itemizedlist>

        <caution>
          <para>The indices of "<sgmltag>phase</sgmltag>",
          "<sgmltag>brake</sgmltag>" and "<sgmltag>yellow</sgmltag>" are from
          right to left, that means the rightmost (last) entry will be later
          found at index 0.</para>
        </caution>

        <para>The next table shows again the meaning of phase/brake/yellow
        combinations:</para>

        <table id="tab_phase_brake_yellow_combinations">
          <title>Meanings of combinations of phase/brake/yellow</title>

          <tgroup cols="4">
            <thead>
              <row>
                <entry>phase</entry>

                <entry>brake</entry>

                <entry>yellow</entry>

                <entry>meaning</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>0 (may not pass)</entry>

                <entry>0 (does not have to brake)</entry>

                <entry>0</entry>

                <entry>may not pass, but does not have to brake--&gt;
                invalid!!</entry>
              </row>

              <row>
                <entry>0 (may not pass)</entry>

                <entry>0 (does not have to brake)</entry>

                <entry>1</entry>

                <entry>may not pass, but does not have to brake --&gt;
                invalid!!</entry>
              </row>

              <row>
                <entry>0 (may not pass)</entry>

                <entry>1 (must brake)</entry>

                <entry>0</entry>

                <entry>the vehicle must brake in front of the tls to regard
                other traffic and must not pass it --&gt; equivalent to a red
                light</entry>
              </row>

              <row>
                <entry>0 (may not pass)</entry>

                <entry>1 (must brake)</entry>

                <entry>1</entry>

                <entry>the vehicle must brake in front of the tls to regard
                other traffic and must not pass it, but the "yellow" value is
                set, so if the vehicle is too fast to stop in front, it will
                be passed --&gt; equivalent to a yellow light</entry>
              </row>

              <row>
                <entry>1 (may pass)</entry>

                <entry>0 (does not have to brake)</entry>

                <entry>0</entry>

                <entry>the vehicle may pass the junction without braking
                (regarding other traffic) --&gt; equivalent to green light for
                streams that may pass the junction without regarding other
                traffic (higher priorised roads)</entry>
              </row>

              <row>
                <entry>1 (may pass)</entry>

                <entry>0 (does not have to brake)</entry>

                <entry>1</entry>

                <entry>invalid combination</entry>
              </row>

              <row>
                <entry>1 (may pass)</entry>

                <entry>1 (must brake)</entry>

                <entry>0</entry>

                <entry>the vehicle may pass the junction but has also to slw
                done in front of the tls to let vehicles on roads with a
                higher priority pass if any --&gt; equivalent to green light
                for streams that have to regard other traffic (lower priorised
                roads)</entry>
              </row>

              <row>
                <entry>1 (may pass)</entry>

                <entry>1 (must brake)</entry>

                <entry>1</entry>

                <entry>invalid combination</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Also some further non-mandatory attributes may be stored within
        the <sgmltag>phase</sgmltag>-tag. until now, these tags are used by
        the actuated and the agentbased tls only. They are:</para>

        <itemizedlist>
          <listitem>
            <para><sgmltag>min_duration</sgmltag>: a minimum duration for the
            phase. The tls-logic may not shorten the duration of the phase
            below this value (int, in seconds)</para>
          </listitem>

          <listitem>
            <para><sgmltag>max_duration</sgmltag>: a maximum duration for the
            phase. The tls-logic may not extend the duration of the phase
            beyond this value (int, in seconds)</para>
          </listitem>
        </itemizedlist>

        <para>There is no possibility to insert values for
        <sgmltag>min_duration</sgmltag> and <sgmltag>max_duration</sgmltag>
        into the network descriptions by now but by hand.</para>
      </sect2>

      <sect2 id="more_tls-loading-representation-connection_streams_tls">
        <title>Connections between Streams and TLS-Logics</title>

        <para>You probably have seen, that the <sgmltag>inclanes-tag</sgmltag>
        is buggy. In fact, the links (connections between two consecutive
        lanes, see above) are added almost at the end of the loading process.
        When a link is built, the tls-logic which controls it is informed
        about it getting the information which stream information is used by
        the link. This information is given as an index to the fields
        <sgmltag>phase</sgmltag>, <sgmltag>brake</sgmltag> and
        <sgmltag>yellow</sgmltag> from the <sgmltag>phase</sgmltag>-element of
        the tls-description described above.</para>

        <para>The information about a link is represented as following
        (example from <filename>cross3ltl.net.xml</filename>):</para>

        <programlisting><sgmltag>&lt;succ edge="1si" lane="1si_0" junction="0"&gt;
   &lt;succlane lane="3o_0" via=":0_12_0" \
      tl="0" linkno="12" yield="1" dir="r" state="t"/&gt;
&lt;/succ&gt; </sgmltag></programlisting>

        <para>Let's consider the element "succlane" only, the element "succ"
        gives us only the names of the edge/lane that is currently processed
        and the junction this edge/lane yields in.</para>

        <itemizedlist>
          <listitem>
            <para><sgmltag>lane</sgmltag>: the connected lane's id (mandatory,
            string)</para>
          </listitem>

          <listitem>
            <para><sgmltag>via</sgmltag>: the connected internal lane's id
            (mandatory, string)</para>

            <caution>
              <para>internal lanes are not yet supported, this is just a
              developer's information by now</para>
            </caution>
          </listitem>

          <listitem>
            <para><sgmltag>tl</sgmltag>: the id of the tls-logic that is
            responsible for this link; this field is missing if the link is
            not controlled by a tls</para>
          </listitem>

          <listitem>
            <para><sgmltag>linkno</sgmltag>: the index of the information
            within the controlling tls logic that shall be used for this
            link</para>
          </listitem>

          <listitem>
            <para><sgmltag>yield</sgmltag>: information whether vehicles have
            to wait in front of this link (valid only for uncontrolled
            links)</para>
          </listitem>

          <listitem>
            <para><sgmltag>dir</sgmltag>: the information about which arrow
            shall be drawn for this link</para>
          </listitem>

          <listitem>
            <para><sgmltag>state</sgmltag>: the information what kind of state
            shall be drawn</para>
          </listitem>
        </itemizedlist>
      </sect2>
    </sect1>

    <sect1 id="more_tls-loading-parsing">
      <title>Parsing the network description</title>

      <para>An instance of NLHandler is used to parse the XML-descriptions of
      the network and of the tls-logics contained herein. All elements related
      to traffic lights and junctions at all are delegated to an instance of
      NLJunctionControlBuilder (from version 0.9.0 on). Herein, the whole
      description is stored temporarily until the complete description has
      been read. Then, as the closing <sgmltag>tl-logic</sgmltag> tag occures,
      the tls logic is build in accordace to the read type.</para>
    </sect1>
  </chapter>

  <chapter id="more_tls-further">
    <title>Further Information</title>

    <para>You can find some further questions posted by users herein.</para>

    <sect1 id="more_tls-further-qa">
      <title>Questions &amp; Answers</title>

      <sect2 id="more_tls-further-qa-changing_duration">
        <title>Changing the duration of Cycles and Phases</title>

        <para><emphasis>Question:</emphasis> I want to study the effects of
        changing the periods of the traffic light. (time green
        left/straight/right in both directions and the "dead time" = all
        directions have red); how do I change the period of the traffic
        light?</para>

        <para><emphasis>Answer:</emphasis> If you have a network that contains
        traffic lights, you can open it with a text editor. Then search for
        "tl-logic". You will find the definition(s) of your traffic light(s).
        Now, you can see a set of "phase"-definitions within each of the
        traffic lights definitions. You can change the time for each phase
        directly in here.</para>
      </sect2>

      <sect2 id="more_tls-further-qa-coupling">
        <title>Coupling Traffic Lights</title>

        <para><emphasis>Question:</emphasis> Is it possible to "connect" two
        traffic lights? In other words, is it possible to say that one light
        has to become green x seconds after the other?</para>

        <para><emphasis>Answer:</emphasis> No, there is no possibility to
        couple traffic lights directly in SUMO. What one can do is to
        synchronize them on-line using TraCI. Also, one can load additional
        programs into SUMO.</para>
      </sect2>
    </sect1>
  </chapter>
</book>